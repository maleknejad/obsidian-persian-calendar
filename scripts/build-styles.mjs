//? Combines all styles(from: src/styles/index.css) into a single file
//? Minifies output using PostCSS + cssnano

import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import postcss from "postcss";
import cssnano from "cssnano";

const filename = fileURLToPath(import.meta.url);
const dirname = path.dirname(filename);

const projectRoot = path.resolve(dirname, "..");
const entryPath = path.join(projectRoot, "src", "styles", "index.css");
const outputPath = path.join(projectRoot, "styles.css");

const importRegex = /@import\s+(?:url\()?['"]([^'"]+)['"]\)?\s*;/g;

function extractImportPaths(css) {
	return Array.from(css.matchAll(importRegex), (match) => match[1]);
}

function stripImports(css) {
	return css.replace(importRegex, "");
}

function resolveImportPath(parentFilePath, importPath) {
	if (!importPath.startsWith(".")) {
		throw new Error(
			`Only relative @import paths are supported (in ${path.relative(
				projectRoot,
				parentFilePath,
			)}, got: ${importPath})`,
		);
	}

	const absolutePath = path.resolve(path.dirname(parentFilePath), importPath);
	const relativePathFromRoot = path.relative(projectRoot, absolutePath);

	if (relativePathFromRoot.startsWith("..") || path.isAbsolute(relativePathFromRoot)) {
		throw new Error(
			`@import path must stay within project root (in ${path.relative(
				projectRoot,
				parentFilePath,
			)}, got: ${importPath})`,
		);
	}

	return {
		absolutePath,
		relativePath: relativePathFromRoot.split(path.sep).join(path.posix.sep),
	};
}

async function resolveCSS(filePath, seen = new Set()) {
	const resolvedPath = path.resolve(filePath);

	if (seen.has(resolvedPath)) {
		return "";
	}
	seen.add(resolvedPath);

	const raw = await fs.readFile(resolvedPath, "utf8");
	const importPaths = extractImportPaths(raw);

	let result = "";

	for (const importPath of importPaths) {
		const { absolutePath } = resolveImportPath(resolvedPath, importPath);
		result += await resolveCSS(absolutePath, seen);
	}

	result += stripImports(raw);

	return result;
}

async function build() {
	const entryContent = await fs.readFile(entryPath, "utf8");
	const directImports = extractImportPaths(entryContent);

	if (directImports.length === 0) {
		throw new Error(`No @import statements found in ${path.relative(projectRoot, entryPath)}`);
	}

	const seenFiles = new Set();
	const combinedCSS = await resolveCSS(entryPath, seenFiles);

	const sourceIndexPath = path
		.relative(projectRoot, entryPath)
		.split(path.sep)
		.join(path.posix.sep);

	const outputRelativePath = path
		.relative(projectRoot, outputPath)
		.split(path.sep)
		.join(path.posix.sep);

	const header = [
		`/*! GENERATED BY: scripts/build-styles.mjs => Source: ${sourceIndexPath} */`,
		"",
	].join("\n");

	const postcssResult = await postcss([
		cssnano({
			preset: [
				"default",
				{
					discardComments: {
						removeAll: true,
					},
				},
			],
		}),
	]).process(combinedCSS, {
		from: sourceIndexPath,
		to: outputRelativePath,
		map: false,
	});

	const finalCSS = header + postcssResult.css;

	let existing = null;
	try {
		existing = await fs.readFile(outputPath, "utf8");
	} catch {}

	if (existing !== finalCSS) {
		await fs.writeFile(outputPath, finalCSS, "utf8");
	}

	console.log('Built minify "styles.css" successfuly.');
}

await build();
